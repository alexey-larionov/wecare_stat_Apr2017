---
title: "trend_analysis_wecare_nfe_jan2017_prelim"
output: html_document
---

started: Alexey Larionov, 27Feb2017  
last updated: Alexey Larionov, 09Mar2017

# Summary

Reads and checks data.  

Checks for control's AFs > 0.5, inverts genotypes and recalculates AFs if needed.  

Weights variants by AFs in controls (ubc) and aggregats variants by gene.  

Then performs trend-like tests within regression framework using proportional odds and multinomial approaches (based on David Conti e-mail of 18Nov2016).    

Calculates aggregated AFs in all sub-groups (nfe, ubc and cbc +/- fam etc), for convinience.  

Writes results into a text file.  

# start_section

```{r start_section}

# Start time
Sys.time()

# Folders
setwd("/scratch/medgen/scripts/wecare_stat_01.17/scripts")
interim_data_folder <- "/scratch/medgen/scripts/wecare_stat_01.17/interim_data"
results_folder <- "/scratch/medgen/scripts/wecare_stat_01.17/results"

# Load libraries
library(MASS) # for proportional odds regression (polr)
source("fixed-polr.R") # fixed version of MASS:plor
# http://r.789695.n4.nabble.com/bugs-and-misfeatures-in-polr-MASS-fixed-td3024677.html
fixed_plor_functions <-
 c("anova.polr", "confint.polr", "confint.profile.polr", "dgumbel", 
   "extractAIC.polr", "logLik.polr", "model.frame.polr", "pgumbel", 
   "polr", "polr.fit", "predict.polr", "print.polr", "print.summary.polr", 
   "profile.polr", "simulate.polr", "summary.polr", "vcov.polr")

# Function for custom error handling
source("tryCatch_AL.R")

library(rms) # for robust alternatives to MASS::plor (orm, lrm)
library(nnet) # for multinomial regression (multinom)

```

# load_data

```{r load_data}

# Load data
load(paste(interim_data_folder, "s07b_filter_by_variant_effect_wecare_nfe_jan2017.RData", sep="/"))

```

# check_data

```{r check_data}

ls()

dim(wecare_nfe_genotypes.mx)
class(wecare_nfe_genotypes.mx)
wecare_nfe_genotypes.mx[1:5,1:5]

dim(wecare_nfe_phenotypes.df)
str(wecare_nfe_phenotypes.df)
wecare_nfe_phenotypes.df[1:5,1:5]

dim(wecare_nfe_variants.df)
colnames(wecare_nfe_variants.df)
wecare_nfe_variants.df[1:5,1:5]

dim(wecare_nfe_kgen.df)
colnames(wecare_nfe_kgen.df)
wecare_nfe_kgen.df[1:5,1:5]

dim(wecare_nfe_exac.df)
colnames(wecare_nfe_exac.df)
wecare_nfe_exac.df[1:5,1:5]

# Check consistency of rownames and colnames
sum(colnames(wecare_nfe_genotypes.mx) != rownames(wecare_nfe_phenotypes.df))
sum(rownames(wecare_nfe_genotypes.mx) != rownames(wecare_nfe_variants.df))
sum(rownames(wecare_nfe_genotypes.mx) != rownames(wecare_nfe_kgen.df))
sum(rownames(wecare_nfe_genotypes.mx) != rownames(wecare_nfe_exac.df))

```

# prepare_data_for_analysis

No missed data in eigenvectors or outcomes

```{r prepare_data_for_analysis}

# Eigenvectors
eigenvectors <- as.matrix(wecare_nfe_phenotypes.df[,c("eig1_wes", "eig2_wes", "eig3_wes")])  
sum(is.na(eigenvectors)) # 0

# Outcomes
Y.num <- wecare_nfe_phenotypes.df$cc + 1 
Y.ofr <- ordered(Y.num, levels=c(0,1,2), labels=c("nfe", "ubc", "cbc"))
names(Y.ofr) <- as.vector(wecare_nfe_phenotypes.df$wes_id)
  
# Genes
genes <- unique(as.vector(wecare_nfe_variants.df$SYMBOL))
length(genes)
sum(is.na(genes))

# Raw AFs headers
raw_afs_cols <- c(
    "ac_wecare_nfe_cln", "an_wecare_nfe_cln", "af_wecare_nfe_cln",
    "ac_nfe_cln", "an_nfe_cln", "af_nfe_cln", 
    "ac_wecare_cln", "an_wecare_cln", "af_wecare_cln", 
    "ac_ubc_cln", "an_ubc_cln", "af_ubc_cln", 
    "ac_cbc_cln", "an_cbc_cln", "af_cbc_cln", 
    "ac_ubc_fam_cln", "an_ubc_fam_cln", "af_ubc_fam_cln", 
    "ac_ubc_nofam_cln", "an_ubc_nofam_cln", "af_ubc_nofam_cln", 
    "ac_cbc_fam_cln", "an_cbc_fam_cln", "af_cbc_fam_cln", 
    "ac_cbc_nofam_cln", "an_cbc_nofam_cln", "af_cbc_nofam_cln")

# Output AFs headers (w/o "_cln")
afs_cols <- c(
    "ac_wecare_nfe", "an_wecare_nfe", "af_wecare_nfe", 
    "ac_nfe", "an_nfe", "af_nfe", 
    "ac_wecare", "an_wecare", "af_wecare", 
    "ac_ubc", "an_ubc", "af_ubc", 
    "ac_cbc", "an_cbc", "af_cbc", 
    "ac_ubc_fam", "an_ubc_fam", "af_ubc_fam", 
    "ac_ubc_nofam", "an_ubc_nofam", "af_ubc_nofam", 
    "ac_cbc_fam", "an_cbc_fam", "af_cbc_fam", 
    "ac_cbc_nofam", "an_cbc_nofam", "af_cbc_nofam")

# Clean-up
rm(Y.num)

```

# do_analysis

Prepare output table, then
loop through each gene: 
- get varaints per gene  
- get tables with varaints and genotypes data  
- check and correct variants with inverted AFs in controls (varaints with nfe ALT AF > 0.5)  
- recalculate AFs (will differ in the inverted varaints)  
- calculate weights and weighted predictive varaible
- perform trend analyses (proportional odds and mukltinomial)  
- write results to text table  

Some errors and warnings are generated by clogit / glm functions.  
They are handled with try() and reported in clogit_mode / glm_mode columns

Chunk options: results='hide', error=FALSE, warning=FALSE  
to suppress clattering with progress reports/errors/warnings

```{r do_analysis, results='hide', error=FALSE, warning=FALSE}

# --- Prepare output table --- # 

# write header to output file
header <- c("gene", "n_variants", "multilaalelic_varaints", "inverted_afs", 
            "polr_info", "polr_LRT", "polr_anova", 
            "orm_info", "orm_LRT", "orm_anova", 
            "lrm_info", "lrm_LRT", "lrm_anova",
            "multinom_info", "multinom_LRT", "multinom_anova", 
            afs_cols)

write(paste(header, sep="", collapse="\t"),
  paste(results_folder, "s08b_trend_analysis_wecare_nfe_jan2017_prelim.txt", sep="/"))

# Clean-up
rm(header)

# Function to count alleles (2x for diploid)
get_allele_number.udf <- function(x){2*sum(!is.na(x))}

# --- Loop through each gene --- #

# Genes for testing:
#gene="ATM" # many variants per gene
#gene="PRKCZ" # one variant per gene 
#gene="ADH1B" # contains a rare version of SNP in ref genome (2 vars altogether); fails polr
#gene="SLC27A3" # contains a multiallelic SNP (8 vars altogether)
#gene="CLC9A3R1" # a candidate from previous analyses
#gene="PANK4" # failed converging in multinomial

#genes <- c("ATM", "PRKCZ", "ADH1B", "SLC27A3", "PANK4", "SLC9A3R1")
#genes <- c("APBA3", "RAX2", "ZFR2", "ATCAY")

for(gene in genes){
  
  # --- Initial settings for a gene --- # 
  #gene="PANK4"
  
  # Get list of variants for the gene
  variants <- wecare_nfe_variants.df$SYMBOL == gene
  num_varaints <- sum(variants)
  var_IDs <- as.vector(wecare_nfe_variants.df[variants,"SplitVarID"])

  # --- Select varaints data --- #
  
  # Notes: 
  
  # I explicitly specify the class (i.e. data frame or matrix) and the num of rows.
  # This is done to ensure that single-variant genes are proecessed as expected; 
  # otherwise they might be converted to vectors etc. 
  
  # It seems that rownames and colnames are preserved, 
  # so I did no explicit provision to assure this. 
  
  variants.df <- as.data.frame(wecare_nfe_variants.df[variants,], nrow=num_varaints)

  # Flag genes containing multiallelics varaints
  multiallelic_varaints <- FALSE
  if(sum(variants.df$"Multiallelic") > 0){
      multiallelic_varaints <- TRUE
  }

  # Raw allelic frequencies and counts
  raw_afs.df <- as.data.frame(variants.df[, raw_afs_cols])
  colnames(raw_afs.df) <- afs_cols # remove tne "_cln" suffic from AFs colnames

  # Raw AFs in controls (nfe)
  raw_afs_in_controls <- variants.df$af_nfe_cln

  # --- Raw genotypes --- #
  
  # Notes: 
  
  # I explicitly specify the class (i.e. data frame or matrix) and the num of rows. 
  # This is done to ensure that singel-variant genes are proecessed as expected; 
  # otherwise they might be converted to vectors etc. 
  
  # It seems that rownames and colnames may NOT be preserved at this occasion, 
  # so I explicitly assigned them too.  

  raw_genotypes.mx <- matrix(wecare_nfe_genotypes.mx[variants,], nrow=num_varaints)
  rownames(raw_genotypes.mx) <- var_IDs
  colnames(raw_genotypes.mx) <- colnames(wecare_nfe_genotypes.mx)

  # Assume no inverted AFs in controls (no controls AFs > 0.5)
  inverted_afs <- FALSE
  afs_in_controls <- raw_afs_in_controls
  genotypes.mx <- raw_genotypes.mx
  afs.df <- raw_afs.df
  
  ##############################################################
  #             Check and correct for inverted AFs             #
  ##############################################################
  
  # For each var in the gene
  for(var in 1:num_varaints){
    
    # var <- 2
    
    # Check whether this variant has inverted controls AF
    if(raw_afs_in_controls[var] > 0.5){
      
      #--------------------------------------------------------#
      #                Set flag for inverted_afs               #
      #--------------------------------------------------------#
      
      inverted_afs <- TRUE
      
      #--------------------------------------------------------#
      #      Update genotypes (swop 0 and 2 in genotypes)      #
      #--------------------------------------------------------#
      
      raw_var_genotypes <- raw_genotypes.mx[var,]
      var_genotypes <- raw_genotypes.mx[var,]
      0 -> var_genotypes[raw_var_genotypes == 2]
      2 -> var_genotypes[raw_var_genotypes == 0]
      var_genotypes -> genotypes.mx[var,]
      
      # Clean-up
      rm(raw_var_genotypes)
      
      #--------------------------------------------------------#
      #                     Recalculate AFs                    #
      #--------------------------------------------------------#
      
      afs.df[var,"ac_wecare_nfe"] <- sum(var_genotypes, na.rm=TRUE)
      afs.df[var,"an_wecare_nfe"] <- get_allele_number.udf(var_genotypes)
      afs.df[var,"af_wecare_nfe"] <- afs.df[var,"ac_wecare_nfe"]/afs.df[var,"an_wecare_nfe"]

      wecare_cases <- wecare_nfe_phenotypes.df$cc == 0 | wecare_nfe_phenotypes.df$cc == 1
      afs.df[var,"ac_wecare"] <- sum(var_genotypes[wecare_cases], na.rm=TRUE)
      afs.df[var,"an_wecare"] <- get_allele_number.udf(var_genotypes[wecare_cases])
      afs.df[var,"af_wecare"] <- afs.df[var,"ac_wecare"]/afs.df[var,"an_wecare"]

      nfe_cases <- wecare_nfe_phenotypes.df$cc == -1
      afs.df[var,"ac_nfe"] <- sum(var_genotypes[nfe_cases], na.rm=TRUE)
      afs.df[var,"an_nfe"] <- get_allele_number.udf(var_genotypes[nfe_cases])
      afs.df[var,"af_nfe"] <- afs.df[var,"ac_nfe"]/afs.df[var,"an_nfe"]

      ubc_cases <- wecare_nfe_phenotypes.df$cc == 0 
      afs.df[var,"ac_ubc"] <- sum(var_genotypes[ubc_cases], na.rm=TRUE)
      afs.df[var,"an_ubc"] <- get_allele_number.udf(var_genotypes[ubc_cases])
      afs.df[var,"af_ubc"] <- afs.df[var,"ac_ubc"]/afs.df[var,"an_ubc"]

      cbc_cases <- wecare_nfe_phenotypes.df$cc == 1 
      afs.df[var,"ac_cbc"] <- sum(var_genotypes[cbc_cases], na.rm=TRUE)
      afs.df[var,"an_cbc"] <- get_allele_number.udf(var_genotypes[cbc_cases])
      afs.df[var,"af_cbc"] <- afs.df[var,"ac_cbc"]/afs.df[var,"an_cbc"]

      ubc_fam_cases <- wecare_nfe_phenotypes.df$cc == 0 & wecare_nfe_phenotypes.df$family_history == 1
      afs.df[var,"ac_ubc_fam"] <- sum(var_genotypes[ubc_fam_cases], na.rm=TRUE)
      afs.df[var,"an_ubc_fam"] <- get_allele_number.udf(var_genotypes[ubc_fam_cases])
      afs.df[var,"af_ubc_fam"] <- afs.df[var,"ac_ubc_fam"]/afs.df[var,"an_ubc_fam"]

      ubc_nofam_cases <- wecare_nfe_phenotypes.df$cc == 0 & wecare_nfe_phenotypes.df$family_history == 0
      afs.df[var,"ac_ubc_nofam"] <- sum(var_genotypes[ubc_nofam_cases], na.rm=TRUE)
      afs.df[var,"an_ubc_nofam"] <- get_allele_number.udf(var_genotypes[ubc_nofam_cases])
      afs.df[var,"af_ubc_nofam"] <- afs.df[var,"ac_ubc_nofam"]/afs.df[var,"an_ubc_nofam"]

      cbc_fam_cases <- wecare_nfe_phenotypes.df$cc == 1 & wecare_nfe_phenotypes.df$family_history == 1
      afs.df[var,"ac_cbc_fam"] <- sum(var_genotypes[cbc_fam_cases], na.rm=TRUE)
      afs.df[var,"an_cbc_fam"] <- get_allele_number.udf(var_genotypes[cbc_fam_cases])
      afs.df[var,"af_cbc_fam"] <- afs.df[var,"ac_cbc_fam"]/afs.df[var,"an_cbc_fam"]

      cbc_nofam_cases <- wecare_nfe_phenotypes.df$cc == 1 & wecare_nfe_phenotypes.df$family_history == 0
      afs.df[var,"ac_cbc_nofam"] <- sum(var_genotypes[cbc_nofam_cases], na.rm=TRUE)
      afs.df[var,"an_cbc_nofam"] <- get_allele_number.udf(var_genotypes[cbc_nofam_cases])
      afs.df[var,"af_cbc_nofam"] <- afs.df[var,"ac_cbc_nofam"]/afs.df[var,"an_cbc_nofam"]
      
      #--------------------------------------------------------#
      #            Check and update the control's af           #
      #--------------------------------------------------------#
      
      if( afs.df[var, "af_nfe"] + raw_afs_in_controls[var] != 1 ){
        stop(paste("Error during AFs inversion, gene:", gene))
      } # there could be rounding diferences in order of 10E-15
      
      afs_in_controls[var] <- afs.df[var, "af_ubc"] 
      
      # Clean-up
      rm(wecare_cases, nfe_cases, ubc_cases, cbc_cases, ubc_fam_cases, 
         ubc_nofam_cases, cbc_fam_cases, cbc_nofam_cases, var_genotypes)

    } # --- done the genotypes inversion for a variant (if needed) --- #

  } # -------------- Check next variant for the gene ----------------- #

  # Clean-up
  rm(raw_afs_in_controls, raw_genotypes.mx, raw_afs.df, var)

  ####################################################################################
  #                   Get aggregated allelic counts and fractions                    #
  ####################################################################################

  afs <- apply(afs.df, 2, sum, na.rm=TRUE)
  afs["af_wecare"] <- afs["ac_wecare"] / afs["an_wecare"]
  afs["af_ubc"] <- afs["ac_ubc"] / afs["an_ubc"]
  afs["af_cbc"] <- afs["ac_cbc"] / afs["an_cbc"]
  afs["af_ubc_fam"] <- afs["ac_ubc_fam"] / afs["an_ubc_fam"]
  afs["af_ubc_nofam"] <- afs["ac_ubc_nofam"] / afs["an_ubc_nofam"]
  afs["af_cbc_fam"] <- afs["ac_cbc_fam"] / afs["an_cbc_fam"]
  afs["af_cbc_nofam"] <- afs["ac_cbc_nofam"] / afs["an_cbc_nofam"]
  
  # Clean-up
  rm(afs.df)
  
  ####################################################################################
  #                     Prepare predictive variable for analyses                     #
  ####################################################################################

  # Transpose genotypes (make variants in columns)
  g <- t(genotypes.mx)
  
  # Impute missed genotypes (variant-wise means)
  g <- apply(g, 2, function(v) { ifelse(is.na(v), mean(v, na.rm=T), v) })

  # Calculate weights (the same as SKAT's default weights)
  w <- dbeta(afs_in_controls, 1, 25)

  # Calculate the predictive variable
  # sum of weighted ACs per case (as n x 1 matrix)
  X <- g%*%w
  
  # Make the variable numewric vector 
  # (not a matrix etc - just in case: a matrix still would work ...)
  X_names  <- rownames(X)
  X <- as.numeric(X)
  names(X) <- X_names
  
  # Clean-up
  rm(genotypes.mx, g, w, X_names)
  
  ####################################################################################
  #       Weighted burden with proportional odds regression for NFE < UBC < CBC      #
  ####################################################################################
  
  # library(MASS)
  # source("fixed-polr.R")
  # source("tryCatch_AL.R")
  
  # Try computing regression models
  try.polr.reg.null <- tryCatch_AL(polr(Y.ofr ~ eigenvectors, Hess=TRUE))
  try.polr.reg <- tryCatch_AL(polr(Y.ofr ~ X + eigenvectors, Hess=TRUE))
  
  # Try computing p-values
  try.polr.chi.stat.LRT <- tryCatch_AL(2*(logLik(try.polr.reg$value) - logLik(try.polr.reg.null$value)))
  try.polr.P.LRT <- tryCatch_AL(1 - pchisq(try.polr.chi.stat.LRT$value, df=1))
  try.polr.P.anova <- tryCatch_AL(anova(try.polr.reg.null$value, try.polr.reg$value)["2","Pr(Chi)"])
  
  # Extract results
  polr.P.LRT <- try.polr.P.LRT$value
  polr.P.anova <- try.polr.P.anova$value

  # Compile info
  if(try.polr.reg.null$info == "error" | 
     try.polr.reg$info == "error" | 
     try.polr.chi.stat.LRT$info == "error"|
     try.polr.P.LRT$info == "error"|
     try.polr.P.anova$info == "error"){
    
    polr.info <- "error"
    
  }else if(try.polr.reg.null$info == "warning" | 
           try.polr.reg$info == "warning" | 
           try.polr.chi.stat.LRT$info == "warning" |
           try.polr.P.LRT$info == "warning" |
           try.polr.P.anova$info == "warning"){

    polr.info <- "warning"
    
  }else{
    
    polr.info <- "success"
    
  }
  
  # Clean-up
  rm(try.polr.reg.null, try.polr.reg, try.polr.chi.stat.LRT, try.polr.P.LRT, try.polr.P.anova)
  
  ####################################################################################
  #    Alternatives to polr for weighted burden with proportional odds regression    #
  ####################################################################################

  # There were errors in MASS:plor function:
  
  # Error in optim(s0, fmin, gmin, method = "BFGS", ...) : 
  # initial value in 'vmmin' is not finite
  # In addition: Warning message:
  # glm.fit: fitted probabilities numerically 0 or 1 occurred 

  # Apparently, this is a well-known plor problem with poor selection of starting values for fitting: 
  # http://r.789695.n4.nabble.com/bugs-and-misfeatures-in-polr-MASS-fixed-td3024677.html
  # http://stackoverflow.com/questions/17839292/polr-ordinal-logistic-regression-in-r
  # http://stats.stackexchange.com/questions/65548/which-model-should-i-use-to-fit-my-data-ordinal-and-non-ordinal-not-normal-an
  
  # Workarounds for this problem include a fixed version of plor (sourced in the start section) 
  # or using other libraries with equivalent (?) functionality (e.g. rms package)
  
  # --------- orm -------- #
  
  # library(rms)
  # source("tryCatch_AL.R")
  
  # Data
  dat <- as.data.frame(cbind(Y.ofr, X, eigenvectors))
  
  # Try compute regression models
  try.orm.reg.null <- tryCatch_AL(orm(Y.ofr ~ eig1_wes + eig2_wes + eig3_wes, data=dat))
  try.orm.reg <- tryCatch_AL(orm(Y.ofr ~ X + eig1_wes + eig2_wes + eig3_wes, data=dat))
  
  # Try compute p-values
  try.orm.chi.stat.LRT <- tryCatch_AL(2*(logLik(try.orm.reg$value) - logLik(try.orm.reg.null$value)))
  try.orm.P.LRT <- tryCatch_AL(1-pchisq(try.orm.chi.stat.LRT$value, df=1))
  try.orm.P.anova <- tryCatch_AL(anova(try.orm.reg$value)["X","P"])

  # Extract results
  orm.P.LRT <- try.orm.P.LRT$value
  orm.P.anova <- try.orm.P.anova$value

  # Compile info
  if(try.orm.reg.null$info == "error" | 
     try.orm.reg$info == "error" | 
     try.orm.chi.stat.LRT$info == "error"|
     try.orm.P.LRT$info == "error"|
     try.orm.P.anova$info == "error"){
    
    orm.info <- "error"
    
  }else if(try.orm.reg.null$info == "warning" | 
           try.orm.reg$info == "warning" | 
           try.orm.chi.stat.LRT$info == "warning" |
           try.orm.P.LRT$info == "warning" |
           try.orm.P.anova$info == "warning"){

    orm.info <- "warning"
    
  }else{
    
    orm.info <- "success"
    
  }
  
  
  # Clean-up
  rm(dat, try.orm.reg.null, try.orm.reg, try.orm.chi.stat.LRT, try.orm.P.LRT, try.orm.P.anova)
  
  # --------- lrm --------- #
  
  # library(rms)
  # source("tryCatch_AL.R")
  
  # Data
  dat <- as.data.frame(cbind(Y.ofr, X, eigenvectors))
  
  # Try compute regression models
  try.lrm.reg.null <- tryCatch_AL(lrm(Y.ofr ~ eig1_wes + eig2_wes + eig3_wes, data=dat))
  try.lrm.reg <- tryCatch_AL(lrm(Y.ofr ~ X + eig1_wes + eig2_wes + eig3_wes, data=dat))
  
  # Try compute p-values
  try.lrm.chi.stat.LRT <- tryCatch_AL(2*(logLik(try.lrm.reg$value) - logLik(try.lrm.reg.null$value)))
  try.lrm.P.LRT <- tryCatch_AL(1-pchisq(try.lrm.chi.stat.LRT$value, df=1))
  try.lrm.P.anova <- tryCatch_AL(anova(try.lrm.reg$value)["X","P"])

  # Extract results
  lrm.P.LRT <- try.lrm.P.LRT$value
  lrm.P.anova <- try.lrm.P.anova$value

  # Compile info
  if(try.lrm.reg.null$info == "error" | 
     try.lrm.reg$info == "error" | 
     try.lrm.chi.stat.LRT$info == "error"|
     try.lrm.P.LRT$info == "error"|
     try.lrm.P.anova$info == "error"){
    
    lrm.info <- "error"
    
  }else if(try.lrm.reg.null$info == "warning" | 
           try.lrm.reg$info == "warning" | 
           try.lrm.chi.stat.LRT$info == "warning" |
           try.lrm.P.LRT$info == "warning" |
           try.lrm.P.anova$info == "warning"){

    lrm.info <- "warning"
    
  }else{
    
    lrm.info <- "success"
    
  }

  # Clean-up
  rm(dat, try.lrm.reg.null, try.lrm.reg, try.lrm.chi.stat.LRT, try.lrm.P.LRT, try.lrm.P.anova)

  ####################################################################################
  #         Weighted burden with multinomial regression for NFE < UBC < CBC          #
  ####################################################################################
  
  # library(nnet)
  # source("tryCatch_AL.R")

  # Try computing regression models
  try.multinom.reg.null <- tryCatch_AL(multinom(Y.ofr ~ eigenvectors, Hess=TRUE))
  try.multinom.reg <- tryCatch_AL(multinom(Y.ofr ~ X + eigenvectors, Hess=TRUE))
  
  # Try computing p-values
  try.multinom.chi.stat.LRT <- tryCatch_AL(2*(logLik(try.multinom.reg$value) - logLik(try.multinom.reg.null$value)))
  try.multinom.P.LRT <- tryCatch_AL(1 - pchisq(try.multinom.chi.stat.LRT$value, df=2))
  try.multinom.P.anova <- tryCatch_AL(anova(try.multinom.reg.null$value, try.multinom.reg$value)["2","Pr(Chi)"])
  
  # Extract results
  multinom.P.LRT <- try.multinom.P.LRT$value
  multinom.P.anova <- try.multinom.P.anova$value

  # Compile info
  if(try.multinom.reg.null$info == "error" | 
     try.multinom.reg$info == "error" | 
     try.multinom.chi.stat.LRT$info == "error"|
     try.multinom.P.LRT$info == "error"|
     try.multinom.P.anova$info == "error"){
    
    multinom.info <- "error"
    
  }else if(try.multinom.reg.null$info == "warning" | 
           try.multinom.reg$info == "warning" | 
           try.multinom.chi.stat.LRT$info == "warning" |
           try.multinom.P.LRT$info == "warning" |
           try.multinom.P.anova$info == "warning"){

    multinom.info <- "warning"
    
  }else{
    
    multinom.info <- "success"
    
  }
  
  # Clean-up
  rm(try.multinom.reg.null, try.multinom.reg, try.multinom.chi.stat.LRT, try.multinom.P.LRT, try.multinom.P.anova)
  
  ####################################################################################
  #                                  Write result                                    #
  ####################################################################################
  
  # Compile result
  # header:   "gene", "n_variants", "multilaalelic_varaints", "inverted_afs", 
  #           "polr_info", "polr_LRT", "polr_anova", 
  #           "orm_info", "orm_LRT", "orm_anova", 
  #           "lrm_info", "lrm_LRT", "lrm_anova",
  #           "multinom_info", "multinom_LRT", "multinom_anova", 
  #           afs_cols)

  result <- c(gene, num_varaints, multiallelic_varaints, inverted_afs, 
              polr.info, polr.P.LRT, polr.P.anova, 
              orm.info, orm.P.LRT, orm.P.anova, 
              lrm.info, lrm.P.LRT, lrm.P.anova, 
              multinom.info, multinom.P.LRT, multinom.P.anova, 
              afs)

  # Record result to the output table
  write(paste(result, sep="", collapse="\t"),
    paste(results_folder, "s08b_trend_analysis_wecare_nfe_jan2017_prelim.txt", sep="/"),
    append = TRUE)

  # Clean-up
  rm(result, variants, variants.df, var_IDs, num_varaints, multiallelic_varaints, 
     afs, afs_in_controls, X, polr.P.LRT, polr.P.anova, orm.P.LRT, orm.P.anova, 
     lrm.P.LRT, lrm.P.anova, multinom.P.LRT, multinom.P.anova, inverted_afs, 
     polr.info, orm.info, lrm.info, multinom.info)

} # next gene

# Clean-up
rm(gene, genes, Y.ofr, eigenvectors, afs_cols, raw_afs_cols, get_allele_number.udf, tryCatch_AL)
rm(list=fixed_plor_functions)
rm(fixed_plor_functions)

```

# read_and_sort_results_table

## Observations
1) orm.P.LRT looks most "sensitive" at low p-values; however it fails in some genes  
2) Fixed polr is robust against failures, but have slightly higher p-values than orm.P.LRT (at the low p-values end, which is important for the study)  
3) Multinomial does not correlate to polr; overall it has a tendency to higher p-values than polr  
4) Anova p-estimates have tendency to higher P-values than LRT in orm/lrm  
5) lrm p-estimates have tendency to higher P-values than orm  

## Conclusions
1) Calculate polr.P.LRT and multinom.P.LRT, as recommended by DC  
2) Calculate orm.P.LRT for comparison  
3) Add columns for warnings/errors in the methods  

```{r read_and_sort_results_table}

# Read results
results.df <- read.table(paste(results_folder, "s08b_trend_analysis_wecare_nfe_jan2017_prelim.txt", sep="/"), header = TRUE)
dim(results.df)
str(results.df)

summary(as.factor(results.df$multilaalelic_varaints))
# FALSE  TRUE 
#  8463   303 

summary(as.factor(results.df$inverted_afs))
# FALSE  TRUE 
#  8618   148 

summary(as.factor(results.df$polr_info))
# success 
#    8564 

summary(as.factor(results.df$orm_info))
#  error success 
#    111    8453 

summary(as.factor(results.df$lrm_info))
#  error success 
#     80    8484 

summary(as.factor(results.df$multinom_info))
#success 
#   8564 

# ------------ Compare P values ------------ #

mean(results.df$polr_LRT)
mean(results.df$polr_anova) # exactly equal to polr_LRT
mean(results.df$orm_LRT, na.rm=TRUE)
mean(results.df$orm_anova, na.rm=TRUE)
mean(results.df$lrm_LRT, na.rm=TRUE) # exactly equal to orm_LRT
mean(results.df$lrm_anova, na.rm=TRUE) # exactly equal to orm_anova
mean(results.df$multinom_LRT)
mean(results.df$multinom_anova)

# ------ Compare RLT to anova ----- #

# polr_LRT and polr_anova are absolutely equal
plot(polr_LRT ~ polr_anova, data=results.df,
     main="polr_LRT = polr_anova")
abline(a=0, b=1, col="blue", lwd=3)

# Trend for orm_LRT < orm_anova
plot(orm_LRT ~ orm_anova, data=results.df,
     main="orm_LRT < orm_anova")
abline(a=0, b=1, col="blue", lwd=3)
#abline(lm(orm_LRT ~ orm_anova, data=results.df))

# Trend for lrm_LRT < lrm_anova
plot(lrm_LRT ~ lrm_anova, data=results.df,
     main="lrm_LRT < lrm_anova")
abline(a=0, b=1, col="blue", lwd=3)

# multinom_LRT and multinom_anova are absolutely equal
plot(multinom_LRT ~ multinom_anova, data=results.df,
     main="multinom_LRT = multinom_anova")
abline(a=0, b=1, col="blue", lwd=3)

# ------ Compare different packages ----- #

plot(polr_LRT ~ multinom_LRT, data=results.df,
     main="polr_LRT differs from multinom_LRT")
abline(a=0, b=1, col="blue", lwd=3)

plot(orm_LRT ~ lrm_LRT, data=results.df,
     main="orm_LRT < lrm_LRT")
abline(a=0, b=1, col="blue", lwd=3)

plot(polr_LRT ~ orm_LRT, data=results.df,
     main="At low P-values polr_LRT > orm_LRT")
abline(a=0, b=1, col="blue", lwd=3)

sum(is.na(results.df$orm_LRT))/length(results.df$orm_LRT)

# ---------------- qq plots ---------------- #

# http://genome.sph.umich.edu/wiki/Code_Sample:_Generating_QQ_Plots_in_R
# http://www.gettinggeneticsdone.com/2014/05/qqman-r-package-for-qq-and-manhattan-plots-for-gwas-results.html 

# It is belived that under null hypothesis the distribution of P-values shoulod be uniform
# e.g. http://physics.rockefeller.edu/luc/technical_reports/cdf8023_facts_about_p_values.pdf
# Hopefully, this holds for the GWAs-WES type of data

obs.pvalues <- as.numeric(results.df$polr_LRT)
exp.pvalues<-(rank(obs.pvalues, ties.method="first") + 0.5)/(length(obs.pvalues)+1)# # note the flat expectation
plot(-log10(exp.pvalues), -log10(obs.pvalues), 
     main="QQ plot for polr_LRT")
abline(0,1,col="red")

obs.pvalues <- as.numeric(results.df$multinom_LRT)
exp.pvalues<-(rank(obs.pvalues, ties.method="first") + 0.5)/(length(obs.pvalues)+1)# # note the flat expectation
plot(-log10(exp.pvalues), -log10(obs.pvalues), 
     main="QQ plot for multinom_LRT")
abline(0,1,col="red")

obs.pvalues <- as.numeric(results.df$orm_LRT[!is.na(results.df$orm_LRT)])
exp.pvalues<-(rank(obs.pvalues, ties.method="first") + 0.5)/(length(obs.pvalues)+1)
plot(-log10(exp.pvalues), -log10(obs.pvalues), 
     main="QQ plot for orm_LRT")
abline(0,1,col="red")

# Sort
results.df <- results.df[order(as.numeric((results.df$polr_LRT))), ] 

# Save sorted
write.table(results.df, 
            file=paste(results_folder, "s08b_trend_analysis_wecare_nfe_jan2017_prelim.txt", sep="/"),
            row.names = FALSE, quote=FALSE, sep="\t")

```

# save_data

```{r save_data}

save.image(paste(interim_data_folder, "s08b_trend_analysis_wecare_nfe_jan2017_prelim.RData", sep="/"))

```

# final_section

```{r final_section}

ls()
sessionInfo()
Sys.time()

```
