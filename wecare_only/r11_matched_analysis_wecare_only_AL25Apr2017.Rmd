---
title: "matched_analysis_wecare_only"
output: html_document
---

started: Alexey Larionov, 27Feb2017  
last updated: Alexey Larionov, 25Apr2017

# Summary

Matched analysis with clogit on SKAT-style weighted and aggregated data  

- Read and check the data  

- Invert genotypes and recalculate AFs if control's AFs > 0.5  

- Weight variants by AFs in controls (ubc)  

- Aggregate variants by gene  

- Perform matched analysis on weighted and aggregated data  

- Compare matched analysis with un-matched glm (Firth?) based on David Conti e-mail of 18Nov2016  

- Calculate aggregated event counts in sub-groups (ubc and cbc +/- fam), for convinience  

- Make QQ-plots  

- Write results into a text file  

# start_section

```{r start_section}

# Start time
Sys.time()

# Folders
#/analysis/mtgroup_share
#/scratch/medgen
setwd("/analysis/mtgroup_share/scripts/wecare_stat_04.17/scripts/wecare_only")
source_data_folder <- "/analysis/mtgroup_share/scripts/wecare_stat_04.17/source_data"
interim_data_folder <- "/analysis/mtgroup_share/scripts/wecare_stat_04.17/scripts/wecare_only/interim_data"
results_folder <- "/analysis/mtgroup_share/scripts/wecare_stat_04.17/scripts/wecare_only/results"

# Load libraries and functions
library(survival) # for clogit (matched analysis)
source("f02_tryCatchAdv.R") # advanced error handling
source("f03_qqunif_plot.R") # for nice qq-plots

```

# load_data

```{r load_data}

load(paste(interim_data_folder, "s08_filter_by_variant_effect_wecare_only.RData", sep="/"))

```

# check_data

```{r check_data}

dim(genotypes.mx)
class(genotypes.mx)
genotypes.mx[1:5,1:5]

dim(genes.df)
class(genes.df)
genes.df[1:5,]

dim(kgen.df)
colnames(kgen.df)
kgen.df[1:5,1:5]

dim(exac.df)
colnames(exac.df)
exac.df[1:5,1:5]

dim(variants.df)
str(variants.df)
variants.df[1:5,1:5]

dim(phenotypes.df)
str(phenotypes.df)
phenotypes.df[1:5,1:5]

# Check consistency of rownames and colnames
sum(colnames(genotypes.mx) != rownames(phenotypes.df))

sum(rownames(genotypes.mx) != rownames(kgen.df))
sum(rownames(genotypes.mx) != rownames(exac.df))
sum(rownames(genotypes.mx) != rownames(variants.df))

```

# invert_genotypes

Invert genotypes and recalculate AFs if control's (ubc) AFs > 0.5  
Similar to "flipping" genotypes in SKAT  

```{r invert_genotypes}

# Prepare tables for output
variants_inv.df <- cbind(variants.df, 
                     inverted=rep(FALSE,nrow(variants.df)),
                     ac_inv=variants.df$ac_all,
                     an_inv=variants.df$an_all,
                     af_inv=variants.df$af_all,
                     ac_cbc_inv=variants.df$ac_cbc,
                     an_cbc_inv=variants.df$an_cbc,
                     af_cbc_inv=variants.df$af_cbc,
                     ac_ubc_inv=variants.df$ac_ubc,
                     an_ubc_inv=variants.df$an_ubc,
                     af_ubc_inv=variants.df$af_ubc)

genotypes_inv.mx <- genotypes.mx

cbc_cases <- phenotypes.df$cc == 1
sum(cbc_cases)

ubc_cases <- phenotypes.df$cc == 0
sum(ubc_cases)

# For each variant
for(var in 1:nrow(variants_inv.df)){
  
  # if control's (ubc) AFs > 0.5
  if(variants_inv.df[var,"af_ubc"] > 0.5){
    
    # Flag variant
    TRUE -> variants_inv.df[var, "inverted"]
    
    # Invert genotypes 
    genotypes <- genotypes_inv.mx[var,]
    genotypes_inv <- genotypes
    0 -> genotypes_inv[genotypes == 2]
    2 -> genotypes_inv[genotypes == 0]
    genotypes_inv -> genotypes_inv.mx[var,]

    # Calculate total inverted AFs
    ac_inv <- sum(genotypes_inv, na.rm=TRUE)
    an_inv <- 2*sum(!is.na(genotypes_inv))
    af_inv <- ac_inv/an_inv

    # Calculate inverted cbc AFs
    ac_cbc_inv <- sum(genotypes_inv[cbc_cases], na.rm=TRUE)
    an_cbc_inv <- 2*sum(!is.na(genotypes_inv[cbc_cases]))
    af_cbc_inv <- ac_cbc_inv/an_cbc_inv

    # Calculate inverted ubc AFs
    ac_ubc_inv <- sum(genotypes_inv[ubc_cases], na.rm=TRUE)
    an_ubc_inv <- 2*sum(!is.na(genotypes_inv[ubc_cases]))
    af_ubc_inv <- ac_ubc_inv/an_ubc_inv

    # Add inverted AFs to the variants data.frame
    variants_inv.df[var, c("ac_inv", "an_inv", "af_inv", 
                           "ac_cbc_inv", "an_cbc_inv", "af_cbc_inv", 
                           "ac_ubc_inv", "an_ubc_inv", "af_ubc_inv")] <- 
      c(ac_inv, an_inv, af_inv, 
        ac_cbc_inv, an_cbc_inv, af_cbc_inv, 
        ac_ubc_inv, an_ubc_inv, af_ubc_inv)
    
    # Clean-up
    rm(genotypes, genotypes_inv, 
       ac_inv, an_inv, af_inv, 
       ac_cbc_inv, an_cbc_inv, af_cbc_inv, 
       ac_ubc_inv, an_ubc_inv, af_ubc_inv)
    
  }
}

# Number of invered variants
sum(variants_inv.df$inverted) # 165

# Some effects of inversion
max(variants_inv.df$af_ubc) # ~0.99
max(variants_inv.df$af_ubc_inv) # 0.5

# clean-up
rm(var, cbc_cases, ubc_cases)

```

# count_variants_and_alleles_per_gene

Note that alleles are counted  
AFTER inversion ("flipping") and  
BEFORE imputation and weighting  

To do: Add information about multilaalelic_varaints and inverted_variants?  


```{r count_variants_and_alleles_per_gene}

# Get list of genes (get rid of NAs !)
genes <- unique(as.character(variants_inv.df$SYMBOL))
length(genes)
sum(is.na(genes))

# Prepare table for output
genes_inv.mx <- matrix(nrow=0, ncol=11)
colnames(genes_inv.mx) <- c("gene", "num_var", 
                            "aggr_ac", "aggr_an", "aggr_af",  
                            "aggr_ac_cbc", "aggr_an_cbc", "aggr_af_cbc", 
                            "aggr_ac_ubc", "aggr_an_ubc", "aggr_af_ubc")

# Get lists of samples
cbc_cases <- phenotypes.df$cc == 1
ubc_cases <- phenotypes.df$cc == 0

# For each gene
for(gene in genes){

  # Get list of variants
  vars <- variants_inv.df$SYMBOL == gene
  
  # Get genotypes matrices
  gt.mx <- genotypes_inv.mx[vars, , drop=FALSE]
  # drop=FALSE prevents converting data frame to vector for single-variant genes  
  # https://stat.ethz.ch/R-manual/R-devel/library/base/html/Extract.data.frame.html  
  gt_cbc.mx <- gt.mx[,cbc_cases]
  gt_ubc.mx <- gt.mx[,ubc_cases]
  
  # Count variants
  num_var <- sum(vars)
  
  # Coutn total alleles
  aggr_ac <- sum(gt.mx, na.rm=TRUE)
  aggr_an <- sum(!is.na(gt.mx))
  aggr_af <- aggr_ac / aggr_an
  
  aggr_ac_cbc <- sum(gt_cbc.mx, na.rm=TRUE)
  aggr_an_cbc <- sum(!is.na(gt_cbc.mx))
  aggr_af_cbc <- aggr_ac_cbc / aggr_an_cbc
  
  aggr_ac_ubc <- sum(gt_ubc.mx, na.rm=TRUE)
  aggr_an_ubc <- sum(!is.na(gt_ubc.mx))
  aggr_af_ubc <- aggr_ac_ubc / aggr_an_ubc
  
  # Record to result matrix 
  genes_inv.mx <- rbind(genes_inv.mx, c(gene, num_var, 
                                        aggr_ac, aggr_an, aggr_af, 
                                        aggr_ac_cbc, aggr_an_cbc, aggr_af_cbc, 
                                        aggr_ac_ubc, aggr_an_ubc, aggr_af_ubc)) 
  
  # Clean-up
  rm(vars, num_var, 
     gt.mx, gt_cbc.mx, gt_ubc.mx, 
     aggr_ac, aggr_an, aggr_af, 
     aggr_ac_cbc, aggr_an_cbc, aggr_af_cbc, 
     aggr_ac_ubc, aggr_an_ubc, aggr_af_ubc)

}

# Check result
dim(genes_inv.mx)

# Assign rownames
genes -> rownames(genes_inv.mx)

# Convert to appropriate datatypes
genes_inv.df <- as.data.frame(genes_inv.mx)
genes_inv.df$gene <- as.vector(genes_inv.df$gene)
genes_inv.df$num_var <- as.numeric(as.vector(genes_inv.df$num_var))

genes_inv.df$aggr_ac <-as.numeric(as.vector(genes_inv.df$aggr_ac))
genes_inv.df$aggr_an <-as.numeric(as.vector(genes_inv.df$aggr_an))
genes_inv.df$aggr_af <-as.numeric(as.vector(genes_inv.df$aggr_af))

genes_inv.df$aggr_ac_cbc <-as.numeric(as.vector(genes_inv.df$aggr_ac_cbc))
genes_inv.df$aggr_an_cbc <-as.numeric(as.vector(genes_inv.df$aggr_an_cbc))
genes_inv.df$aggr_af_cbc <-as.numeric(as.vector(genes_inv.df$aggr_af_cbc))

genes_inv.df$aggr_ac_ubc <-as.numeric(as.vector(genes_inv.df$aggr_ac_ubc))
genes_inv.df$aggr_an_ubc <-as.numeric(as.vector(genes_inv.df$aggr_an_ubc))
genes_inv.df$aggr_af_ubc <-as.numeric(as.vector(genes_inv.df$aggr_af_ubc))

str(genes_inv.df)

# Clean-up
rm(genes_inv.mx, gene, genes, cbc_cases, ubc_cases)

```

# impute_missed_data

Substitute NA with duplicated allelic frequency (after inversion)  
Equivalent to the "fixed" imputation approach in SKAT  

```{r impute_missed_data}

# Prepare matrix for output
genotypes_inv_imp.mx <- genotypes_inv.mx

# Fraction of missed data
sum(is.na(genotypes_inv_imp.mx))/
  (nrow(genotypes_inv_imp.mx)*ncol(genotypes_inv_imp.mx)) # ~2.7%

# Impute missed data
for(var in 1:nrow(genotypes_inv_imp.mx)){

    # Get AF (corrected for the inverted variants)
    af <- variants_inv.df[var,"af_inv"]
    
    # Impute missed genotypes
    genotypes <- genotypes_inv_imp.mx[var,]
    2*af -> genotypes[is.na(genotypes)]
    genotypes -> genotypes_inv_imp.mx[var,]

    # Clean-up
    rm(af, genotypes)

}

# Check the result
sum(is.na(genotypes_inv_imp.mx)) # 0%

# Clean-up
rm(genotypes_inv.mx, var)

```

# weight_variants_by_af_in_controls

Weight by total AF using dbeta(UBC_AF,0,25)  
Similar to the default weighting in SKAT  
Ask DC about possible effect for one-variant genes (I expect - no efect?)  

```{r weight_variants_by_af_in_controls}

# Prepare tables for output
variants_inv_wt.df <- variants_inv.df
variants_inv_wt.df <- cbind(variants_inv_wt.df, weight=1)

genotypes_inv_imp_wt.mx <- genotypes_inv_imp.mx

# Apply weighting
for(var in 1:nrow(genotypes_inv_imp_wt.mx)){
  
  # Calculate weight (use UBC AF, recalculated for inverted variants)
  weight <- dbeta(variants_inv_wt.df[var, "af_ubc_inv"], 1, 25)
  
  # Write weight to variants table
  weight -> variants_inv_wt.df[var,"weight"]
  
  # Apply weights to genotypes table
  weight * genotypes_inv_imp_wt.mx[var,] -> genotypes_inv_imp_wt.mx[var,]
  
  # Clean-up
  rm(weight)

}

# clean-up
rm(var, genotypes_inv_imp.mx, variants_inv.df)

```

# aggregate_data_per_gene

```{r aggregate_data_per_gene}

# Get list of genes (get rid of NAs !)
genes <- unique(as.character(variants_inv_wt.df$SYMBOL))
length(genes)
sum(is.na(genes))

# Prepare results matrix
genes_aggr.mx <- matrix(nrow=0, ncol=ncol(genotypes_inv_imp_wt.mx))
colnames(genes_aggr.mx) <- colnames(genotypes_inv_imp_wt.mx)

#genes <- c("ATM", "CASP9", "ADH1B", "SLC27A3", "SLC9A3R1", "CCDC27", "TTLL10")

for(gene in genes){
  
  #gene="ATM"
  
  # Get list of variants
  vars <- variants_inv_wt.df$SYMBOL == gene
  
  # Get genotypes matrices
  gt.mx <- genotypes_inv_imp_wt.mx[vars, , drop=FALSE]

  # Aggregate
  aggr_gene <- apply(gt.mx,2,sum)
  
  # Add to results matrix
  genes_aggr.mx <- rbind(genes_aggr.mx, aggr_gene)
  
  # Clean-up
  rm(vars, gt.mx, aggr_gene)
  
}

# Add rownames
genes -> rownames(genes_aggr.mx)

# Check result
dim(genes_aggr.mx)

# Clean-up
rm(gene, genes)

```


# --- Start a new script --- #

# prepare_data_for_clogit_and_glm

Verifying that there is No missed data   

```{r prepare_data_for_analysis}

# Eigenvectors
E <- as.matrix(phenotypes.df[,c("eig1", "eig2")])
sum(is.na(E)) # 0

# Pairs IDs (for clogit)
P <- phenotypes.df$setno
sum(is.na(P)) # 0

# Matching information (for glm)
M <- as.matrix(phenotypes.df[,c("age_dx", "rstime")])
sum(is.na(M)) # 0

# Make a variable for hormone treatment.
hormone <- phenotypes.df$hormone

# Make variable for cytotoxic treatment
chemo <- phenotypes.df$chemo_cat != "no"

# Make joined treatment variable
treatment <- as.integer(chemo | hormone)
sum(is.na(treatment))

# Number of pregnancies
num_preg <- as.integer(phenotypes.df$num_preg)
sum(is.na(num_preg))

# Bind clinical covariates together
C <- cbind(treatment, num_preg)

# Outcomes
Y <- phenotypes.df$cc
sum(is.na(Y))

# Clean-up
rm(chemo, hormone, treatment, num_preg)

```

# run_clogit

~5-10 min  

```{r run_clogit}

# Get list of genes (get rid of NAs !)
genes <- unique(as.character(variants_inv_wt.df$SYMBOL))
length(genes)
sum(is.na(genes))

# Prepare output matrix
header <- c("gene", "clogit_mode", "p_clogit_lrt", "p_clogit_anova", "p_clogit_wald", 
            "std_clogit_status", "std_clogit_message", "std_clogit_null_status", "std_clogit_null_message", 
            "appr_clogit_status", "appr_clogit_message", "appr_clogit_null_status", "appr_clogit_null_message")

clogit.mx <- matrix(nrow=0, ncol=length(header))
header -> colnames(clogit.mx)  

#genes <- c("ATM", "CASP9", "ADH1B", "SLC27A3", "SLC9A3R1", "CCDC27", "TTLL10")

# For each gene
for(gene in genes){
  
  #gene="CCDC27"
  
  # Get explanatory vector  
  X <- genes_aggr.mx[gene,]

  # Try standard clogit
  # See details within the tryCatchAdv() function
  clogit_reg <- tryCatchAdv(clogit( Y ~ X + E + C + strata(P)))
  clogit_reg_null <- tryCatchAdv(clogit( Y ~ E + C + strata(P)))
  
  # Get status (success or error/warning) and error/warning messages (if any)
  std_clogit_status <- clogit_reg$status
  std_clogit_message <- clogit_reg$message
  
  std_clogit_null_status <- clogit_reg_null$status
  std_clogit_null_message <- clogit_reg_null$message
  
  # If both models run without error
  if( std_clogit_status != "error" & std_clogit_null_status != "error"){
    
    # Update clogit mode
    clogit_mode <- "standard"

    # Get results
    clogit_reg <- clogit_reg$value
    clogit_reg_null <- clogit_reg_null$value
    
    # Extract text from warning message objects (if any)
    if(std_clogit_status == "warning") std_clogit_message <- std_clogit_message$message
    if(std_clogit_null_status == "warning") std_clogit_null_message <- std_clogit_null_message$message

    # Calculate LRT p-estimate
    chi_stat_lrt = 2*(logLik(clogit_reg) - logLik(clogit_reg_null))
    p_clogit_lrt = 1 - pchisq(chi_stat_lrt, df=1)
    
    # Calculate LRT p-estimate using anova()
    clogit_anova <- anova(clogit_reg, clogit_reg_null)
    p_clogit_anova <- clogit_anova[2,"P(>|Chi|)"]
    
    # Get Wald p-estimate
    p_clogit_wald <- summary(clogit_reg)$coef["X", "Pr(>|z|)"]
    
    # Update statuses and messages for appr clogit
    appr_clogit_status <- NA
    appr_clogit_message <- NA
    appr_clogit_null_status <- NA
    appr_clogit_null_message <- NA
    
    # Clean-up
    rm(clogit_reg, clogit_reg_null, chi_stat_lrt, clogit_anova)
    
  # If standard clogit failed, e.g.
  # http://r.789695.n4.nabble.com/Error-when-running-Conditional-Logit-Model-td948556.html 
  } else {
    
    # Get text out of error/warning message objects
    if(std_clogit_status != "succeeded") std_clogit_message <- std_clogit_message$message
    if(std_clogit_null_status != "succeeded") std_clogit_null_message <- std_clogit_null_message$message
    
    # Try approximate clogit
    # http://stats.stackexchange.com/questions/109222/conditional-logistic-regression-model-does-not-converge-but-logistic-regression
    clogit_reg <- tryCatchAdv(clogit( Y ~ X + E + C + strata(P), method="approximate"))
    clogit_reg_null <- tryCatchAdv(clogit( Y ~ E + C + strata(P), method="approximate"))
    
    appr_clogit_status <- clogit_reg$status
    appr_clogit_message <- clogit_reg$message
    
    appr_clogit_null_status <- clogit_reg_null$status
    appr_clogit_null_message <- clogit_reg_null$message

    # If both models run without error
    if( appr_clogit_status != "error" & appr_clogit_null_status != "error"){

      # Update clogit mode
      clogit_mode <- "approximate"

      # Capture results
      clogit_reg <- clogit_reg$value
      clogit_reg_null <- clogit_reg_null$value
  
      # Extract text from warning message objects (if any)
      if(appr_clogit_status == "warning") appr_clogit_message <- appr_clogit_message$message
      if(appr_clogit_null_status == "warning") appr_clogit_null_message <- appr_clogit_null_message$message

      # Calculate LRT p-estimate
      chi_stat_lrt = 2*(logLik(clogit_reg) - logLik(clogit_reg_null))
      p_clogit_lrt = 1 - pchisq(chi_stat_lrt, df=1)
      
      # Calculate LRT p-estimate using anova()
      clogit_anova <- anova(clogit_reg, clogit_reg_null)
      p_clogit_anova <- clogit_anova[2,"P(>|Chi|)"]
      
      # Get Wald p-estimate
      p_clogit_wald <- summary(clogit_reg)$coef["X", "Pr(>|z|)"]
      
      # Clean-up
      rm(clogit_reg, clogit_reg_null, chi_stat_lrt, clogit_anova)
    
    # If approximate clogit failed (as well as the standard one)
    } else {
      
      # Get text out of error/warning message objects
      if(appr_clogit_status != "succeeded") appr_clogit_message <- appr_clogit_message$message
      if(appr_clogit_null_status != "succeeded") appr_clogit_null_message <- appr_clogit_null_message$message
      
      clogit_mode <- "failed"
      p_clogit_lrt <- NA
      p_clogit_anova <- NA
      p_clogit_wald <- NA
      
      # clean-up
      rm(clogit_reg, clogit_reg_null)

    } # closing appr clogit if()
  
  } # closing std clogit if()
  
  # Compile result
  result <- c(gene, clogit_mode, p_clogit_lrt, p_clogit_anova, p_clogit_wald, 
            std_clogit_status, std_clogit_message, std_clogit_null_status, std_clogit_null_message, 
            appr_clogit_status, appr_clogit_message, appr_clogit_null_status, appr_clogit_null_message)
  
  # Add result to output table
  clogit.mx <- rbind(clogit.mx, result)
  
  # Clean-up
  rm(X, clogit_mode, p_clogit_lrt, p_clogit_anova, p_clogit_wald, 
     std_clogit_status, std_clogit_message, std_clogit_null_status, std_clogit_null_message, 
     appr_clogit_status, appr_clogit_message, appr_clogit_null_status, appr_clogit_null_message,
     result)

} # Next gene

# Add rownames
genes -> rownames(clogit.mx)

# Check the result
dim(clogit.mx)

# Convert to data frame (and update data types?)
clogit.df <- as.data.frame(clogit.mx)
str(clogit.df)

# Count errors and warnings
summary(clogit.df$clogit_mode)

sum(clogit.df$clogit_mode == "standard")
sum(clogit.df$clogit_mode == "standard" & (clogit.df$std_clogit_status == "warning" | clogit.df$std_clogit_null_status == "warning"))
sum(clogit.df$clogit_mode == "standard" & clogit.df$std_clogit_status == "succeeded" & clogit.df$std_clogit_null_status == "succeeded")

sum(clogit.df$clogit_mode == "approximate")
sum(clogit.df$clogit_mode == "approximate"  & (clogit.df$appr_clogit_status == "warning" | clogit.df$appr_clogit_null_status == "warning"))
sum(clogit.df$clogit_mode == "approximate" & clogit.df$appr_clogit_status == "succeeded" & clogit.df$appr_clogit_null_status == "succeeded")

...

# Write result to file
output_file <- paste(results_folder, "r10_matched_analysis_wecare_only.txt", sep="/")
write.table(clogit.df, file=output_file, header=TRUE, )

# Clean-up
rm(output_file, header, clogit.mx)

```

# explore_results

```{r explore_results}

# Read results
results.df <- read.table(paste(results_folder, "s08a_3_matched_analysis_wecare_only_Mar2017.txt", sep="/"), header = TRUE)
dim(results.df)
str(results.df)

summary(as.factor(results.df$multilaalelic_varaints))
# FALSE  TRUE 
#  8463   303 

summary(as.factor(results.df$inverted_afs))
# FALSE  TRUE 
#  8618   148 

summary(as.factor(results.df$clogit_mode))
#  approximate  failed_anova failed_clogit      standard 
#          601            19            45          8,101 

summary(as.factor(results.df$glm_mode)) 
# standard: 8,766

# ------------ Compare P values ------------ #
mean_p_values <- c(
  mean(results.df$p_clogit, na.rm=TRUE),
  mean(results.df$p_clogit_anova, na.rm=TRUE),
  mean(results.df$p_glm),
  mean(results.df$p_glm_lrt))
names(mean_p_values) <- c("clogit", "clogit_anova", "glm", "glm_lrt")
barplot(mean_p_values)

colours <- as.vector(results.df$clogit_mode)
"black" -> colours[colours == "standard"]
"red" -> colours[colours == "approximate"]
"green" -> colours[colours == "failed_clogit"]
"green" -> colours[colours == "failed_anova"]

plot(p_glm_lrt ~ p_clogit_anova, data=results.df,
     col=colours, main="glm_lrt vs clogit_anova")
abline(a=0, b=1, col="blue", lwd=3)
legend("bottomright", inset=.05, 
       title="clogit mode:",
       c("standard", "approximate"), 
       fill=c("black", "red"),
       horiz = TRUE)

plot(p_clogit ~ p_clogit_anova, data=results.df, 
     col=colours, main="p_clogit vs clogit_anova")
abline(a=0, b=1, col="blue", lwd=3)
legend("bottomright", inset=.05, 
       title="clogit mode:",
       c("standard", "approximate"), 
       fill=c("black", "red"),
       horiz = TRUE)

plot(p_glm ~ p_glm_lrt, data=results.df, 
     col=colours, main="p_glm vs p_glm_lrt")
abline(a=0, b=1, col="blue", lwd=3)
legend("bottomright", inset=.05, 
       title="clogit mode:",
       c("standard", "approximate", "failed"), 
       fill=c("black", "red", "green"),
       horiz = TRUE)

# ---------------- qq plots ---------------- #

# http://genome.sph.umich.edu/wiki/Code_Sample:_Generating_QQ_Plots_in_R
# http://www.gettinggeneticsdone.com/2014/05/qqman-r-package-for-qq-and-manhattan-plots-for-gwas-results.html 

# It is belived that under null hypothesis the distribution of P-values shoulod be uniform
# e.g. http://physics.rockefeller.edu/luc/technical_reports/cdf8023_facts_about_p_values.pdf
# Hopefully, this holds for the GWAs-WES type of data

obs.pvalues <- as.numeric(results.df$p_glm_lrt)
exp.pvalues<-(rank(obs.pvalues, ties.method="first") + 0.5)/(length(obs.pvalues)+1)# # note the flat expectation
plot(-log10(exp.pvalues), -log10(obs.pvalues), 
     xlim = c(0,4.5), ylim = c(0,4.5),
     main="CBC vs UBC: p_glm_lrt")
abline(0,1,col="red")

qqunif.plot(obs.pvalues, main="CBC vs UBC: p_glm_lrt")

obs.pvalues <- as.numeric(results.df$p_clogit_anova[!is.na(results.df$p_clogit_anova)])
exp.pvalues<-(rank(obs.pvalues, ties.method="first") + 0.5)/(length(obs.pvalues)+1)
plot(-log10(exp.pvalues), -log10(obs.pvalues), 
     xlim = c(0,4.5), ylim = c(0,4.5),
     main="CBC vs UBC: p_clogit_anova")
abline(0,1,col="red")

qqunif.plot(obs.pvalues, main="CBC vs UBC: p_clogit_anova")

# --- Sort --- #

results.df <- results.df[order(as.numeric((results.df$p_glm_lrt))), ] 

# Save sorted
write.table(results.df, 
            file=paste(results_folder, "s08a_3_matched_analysis_wecare_only_Mar2017.txt", sep="/"),
            row.names = FALSE, quote=FALSE, sep="\t")

```

# save_data

```{r save_data}

save.image(paste(interim_data_folder, "s08a_3_matched_analysis_wecare_only_Mar2017.RData", sep="/"))

```

# final_section

```{r final_section}

ls()
sessionInfo()
Sys.time()

```
